'use strict';

let Promise = require('bluebird');
let _ = require('lodash');
let logger = require('log4js').getLogger();
let fs = Promise.promisifyAll(require('fs'));

Promise.coroutine.addYieldHandler(function(val) {
    if(Array.isArray(val)) return Promise.all(val);
});

Promise.coroutine(function* () {
    var argv = require('minimist')(process.argv.slice(2));
    var dbUri = argv._[0];

    if(!dbUri) {
        logger.fatal('Must provide a database uri. Usage node --harmony %s <dbUri>', process.argv[1])
        process.exit(1);
    }

    let region = 'us-west-1';
    let db = yield require('../../connect')(dbUri, {}, logger);

    let defaultData = JSON.parse(fs.readFileSync(__dirname+'/transferData.json'));
    if(!defaultData) {
        logger.fatal('No default data provided, this is required to setup a new environment');
        process.exit(1);
    }

    logger.info('Creating new database for environment %s in region %s', env, region);

    // /**************************************************
    //                     Bucket creation
    //  **************************************************/
    let AWS = require('aws-sdk');
    AWS.config.update(require('./awsCredentials'));
    let s3 = Promise.promisifyAll(new AWS.S3());

    let bucketName = 'digbil-'+region+'-'+env;
    logger.info('Creating bucket `%s` if it doesn\'t exist yet', bucketName);

    yield s3.getBucketLocationAsync({Bucket: bucketName})
    .then(function() {
        logger.info('bucket `%s` is there', bucketName);
    })
    .catch(function(err) {
        logger.info('bucket does not exist, creating it');
        return s3.createBucketAsync({ Bucket: bucketName })
        .then(function() {
            logger.info('bucket `%s` created', bucketName);
        });
    });


    /**************************************************
                    Create digbil entity
     **************************************************/

    let Entity = db.model('entities');
    let digbil = yield Entity.findOne()
        .where('name', /digbil/i)
        .exec();

    if(digbil) {
        logger.info('Digbil entity already there %s', digbil._id);
    } else {
        logger.info('Creating Digbil entity');
        // no logo, the UI set a default one with the digbil logo
        digbil = new Entity({
            emails: [ 'admin@digbil.com' ],
            media_len_quota: 1000003,
            name: 'Digbil Inc. (DON\'T DELETE OR DEATH MAY OCCUR)',
            privileges: {
                entity: true,
                mmb: true,
                locations: true,
                floorplans: true,
                signtypes: true,
                signs: true
            },
            stat: 1,
            street: '臺北市中山區民權東路3段2號11樓',
            tax_id: '53553796',
            tel: '+886 2 123 4567',
            tier: 'Digbil',
            user_quota: 10007,
            addr: []
        });
        yield Promise.promisify(digbil.save, digbil)();
        logger.info('Entity Digbil created with id %s', digbil._id);
    }

    /**************************************************
                Creating roles and privileges
     **************************************************/

    let Roles = db.model('roles');
    let defaultRoles = require('./defaultRoles');
    logger.info('Creating default roles');

    let roles = yield defaultRoles.map(Promise.coroutine(function* (roleData) {
        let dbRole = yield Roles.findOne()
        .where('entity', digbil._id)
        .where('code', roleData.code)
        .exec();

        if(dbRole) {
            logger.info('Role %s already there, skip creation', roleData.name);
            return dbRole;
        }
        logger.info('Creating role %s', roleData.name);
        let role = new Roles(roleData);
        role.entity = digbil._id;
        yield Promise.promisify(role.save, role)();
        return role;
    }));
    let superAdmin = _.find(roles, function(role) {
        return role.name === 'Super Admin';
    });

    logger.info('Creating privileges');

    let privilegePolicy = require('./privilegePolicy').PrivilegePolicy;
    let Permissions = db.model('permissions');
    yield roles.map(Promise.coroutine(function* (role) {
        yield role.privileges.map(Promise.coroutine(function* (priv) {
            let policy = privilegePolicy[priv.function];

            if(!policy) return;
            return yield policy.map(Promise.coroutine(function* (type) {
                let permission = yield Permissions.findOne()
                .where('entity', digbil._id)
                .where('rtype', type)
                .where('role', role._id)
                .exec();

                if(permission) return;

                let rights = '';
                if(priv.create) rights += 'C';
                if(priv.read) rights += 'R';
                if(priv.update) rights += 'U';
                if(priv.delete) rights += 'D';

                permission = Permissions({
                    role: role._id,
                    entity: digbil._id,
                    all_doc: true,
                    rights: rights,
                    rtype: type
                });
                return yield Promise.promisify(permission.save, permission)();

            }));
        }));
    }));

    logger.info('Roles and privileges created');

    /**************************************************
              Creating super user for entity
     **************************************************/

    let User = db.model('userprofile');
    let owner = yield User.findOne()
        .where('entity', digbil._id)
        .where('role', superAdmin._id)
        .exec();

    if(owner) {
        logger.info('Super admin user already created with id: %s', owner._id);
    } else {
        logger.info('Creating a super admin owner of digbil');
        owner = new User({
            role_name: superAdmin.name,
            role: superAdmin._id,
            entity_name: digbil.name,
            entity: digbil._id,
            fn: 'Digbil owner',
            ln: 'inc',
            stat: 1,

            // password is abc123
            pass: 'ea0e7d6d9870c612d88c43e88d0fd2c48c25b90ce7e38a69f179060f0d84493a2f65024b82964242b868dec246f0dacafd008f79ab7a73c4efaf73f15b72610b',
            salt: '05ff0305bb74db843cdbce0716e547e58a531ae25f9920b1d7ffd6688e6141bd71483cb1fa6ddd67e4cab93170a9bd8b1be3181c05e9f4930451c614031fd23f',

            email: [{
                addr: 'admin@digbil.com',
                isdef: true,
                stat: 1
            }],

            service: [{
                type: 'UI',
                stat: 1,
                access_level: 0
            }, {
                type: 'DS',
                stat: 1,
                access_level: 0
            }],

            setting: {
                email_notifications: {
                    camp_warning: true,
                    camp_status: true,
                    media_status: true,
                    ds_status: true
                }
            }
        });

        yield Promise.promisify(owner.save, owner)();
        logger.info('New super admin user created with id %s', owner._id);
    }

    if(!digbil.user) {
        logger.info('Assigning %s as owner of digbil', owner._id);
        digbil.user = owner._id;
        yield Promise.promisify(digbil.save, digbil)();
    }


    /**************************************************
          restoring widgets and layout from dump
     **************************************************/

    logger.info('Using mongodump to create data for email templates and widgets');

    let exec = Promise.promisify(require('child_process').exec)
    let restoreCmd = 'mongorestore --host '+dbData.host
        + ' --port '+dbData.port
        + ' --db '+dbData.db;

    if(dbData.user) restoreCmd += ' -u '+dbData.user;
    if(dbData.password) restoreCmd += ' -p '+dbData.password;

    let restoreNotifCmd = restoreCmd + ' -c notification_templates '
        + __dirname
        +'/notification_templates.dump/digbil_int/notification_templates.bson';

    logger.info('Starting restoring notifications templates from dump');
    yield exec(restoreNotifCmd);
    logger.info('Notifications templates restored from dump');


    let restoreWidgetCmd = restoreCmd + ' -c widget '
        + __dirname
        +'/widget.dump/digbil_int/widget.bson';

    logger.info('Starting restoring widgets from dump');
    yield exec(restoreWidgetCmd);
    logger.info('Widgets restored from dump');

    let Widget = db.model('widget');
    yield Widget.update({}, {
        $set: { user: owner._id }
    }, { multi: true }).exec();
    logger.info('Correct user set for all widgets');


    /**************************************************
          Creating default content for entities
     **************************************************/
    let defaultMedias = defaultData;
    let Media = db.model('media');
    let alreadyThere = yield Media.find().where('default', true).exec();
    if(alreadyThere.length == 0) {
        yield defaultMedias.map(function(data) {
            var defaultMedia = new Media(_.assign(data, {
                user: owner._id,
                default: true,
                entity: digbil._id
            }));
            return Promise.promisify(defaultMedia.save, defaultMedia)();
        });
        logger.info('Default medias created');
    } else {
        logger.info('%d default medias already in db, skipping insertion of new ones', alreadyThere.length);
    }

    let Layout = db.model('layout');
    alreadyThere = yield Layout.find().where('default', true).exec();

    if(alreadyThere.length == 0) {
        let defaultLayouts = JSON.parse(fs.readFileSync(__dirname+'/defaultLayouts.json'));
        let dbWidgets = yield db.model('widget').find().exec();
        let dbWidgetMap = {}; // map name - id
        dbWidgets.forEach(function(widget) {
            dbWidgetMap[widget.name] = widget._id;
        });

        yield defaultLayouts.map(function(layout) {
            layout.widgets.forEach(function(widget) {
                widget.widget = dbWidgetMap[widget.name];
            });
            layout.default = true;
            layout.entity = digbil._id;
            layout.user = owner._id;
            let defaultLayout = new Layout(layout);
            return Promise.promisify(defaultLayout.save, defaultLayout)();
        });

        logger.info('Default layouts created');
    } else {
        logger.info('%d default layouts already in db, skipping insertion of new ones', alreadyThere.length);
    }


    logger.info('^( ^.^ )^ (> ^.^)> ^( ^.^ )^ <(^.^ <) v( ^.^ )v ^( ^.^ )^');
    logger.info('Environment '+env+' created and ready to be used.');
    process.exit(0);

})().catch(function(err) {
    logger.error(err.message, err.stack);
});
